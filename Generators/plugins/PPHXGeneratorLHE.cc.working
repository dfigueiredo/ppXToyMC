// -*- C++ -*-
//
// Package:    test/PPHXGeneratorLHE
// Class:      PPHXGeneratorLHE
//
/**\class PPHXGeneratorLHE 
Description: pp->pp + S(H+X) toy MC. LHE output for further hadronization of the jets.
Implementation:
Based on TauAnalysis/MCEmbeddingTools/plugins/PPHXGeneratorLHE.cc, from Stefan Wayand
*/
//
//         Author:  Diego Figueiredo
//         Created:  Wed, 26 Jan 2021 10:55:03 GMT
//
//

// system include files
#include <algorithm>
#include <iostream>
#include <iterator>
#include <fstream>
#include <string>
#include <memory>
#include "TLorentzVector.h"

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/one/EDProducer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/Run.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "DataFormats/VertexReco/interface/Vertex.h"
#include "DataFormats/VertexReco/interface/VertexFwd.h"
#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/Math/interface/LorentzVector.h"

#include "SimDataFormats/GeneratorProducts/interface/LesHouches.h"
#include "SimDataFormats/GeneratorProducts/interface/LHECommonBlocks.h"
#include "SimDataFormats/GeneratorProducts/interface/LHERunInfoProduct.h"
#include "SimDataFormats/GeneratorProducts/interface/LHEEventProduct.h"
#include "SimDataFormats/GeneratorProducts/interface/LHEXMLStringProduct.h"

#include "GeneratorInterface/LHEInterface/interface/LHERunInfo.h"
#include "GeneratorInterface/LHEInterface/interface/LHEEvent.h"
#include "GeneratorInterface/LHEInterface/interface/LHEReader.h"

#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "FWCore/Utilities/interface/RandomNumberGenerator.h"
#include "FWCore/Utilities/interface/StreamID.h"
#include "CLHEP/Random/RandExponential.h"

//
// class declaration
//

namespace CLHEP {
  class HepRandomEngine;
}

class PPHXGeneratorLHE : public edm::one::EDProducer<edm::BeginRunProducer, edm::EndRunProducer> {
  public:
    explicit PPHXGeneratorLHE(const edm::ParameterSet &);
    ~PPHXGeneratorLHE() override;

    static void fillDescriptions(edm::ConfigurationDescriptions &descriptions);

  private:
    void beginJob() override;
    void produce(edm::Event &, const edm::EventSetup &) override;
    void endJob() override;

    void beginRunProduce(edm::Run &run, edm::EventSetup const &es) override;
    void endRunProduce(edm::Run &, edm::EventSetup const &) override;

    void fill_lhe_jets(TLorentzVector &b1,
	TLorentzVector &b2,
	lhef::HEPEUP &outlhe,
	CLHEP::HepRandomEngine *engine);
    void fill_lhe_with_particle(lhef::HEPEUP &outlhe, TLorentzVector &particle, int pdgid, double spin, double ctau);

    void transform_mumu_to_tautau(TLorentzVector &b1, TLorentzVector &b2);
    void rotate180(TLorentzVector &b1, TLorentzVector &b2);

    LHERunInfoProduct::Header give_slha();

    edm::EDGetTokenT<reco::VertexCollection> vertexCollection_;
    int particleToEmbed_;
    bool rotate180_;
    const double tauMass_ = 1.77682;
    const double elMass_ = 0.00051;

    std::ofstream file;
    bool write_lheout;

};

//
// constructors and destructor
//
PPHXGeneratorLHE::PPHXGeneratorLHE(const edm::ParameterSet &iConfig) {

  //register your products
  produces<LHEEventProduct>();
  produces<LHERunInfoProduct, edm::Transition::BeginRun>();
  produces<math::XYZTLorentzVectorD>("vertexPosition");

  vertexCollection_ = consumes<reco::VertexCollection>(iConfig.getParameter<edm::InputTag>("vertices"));
  rotate180_ = iConfig.getParameter<bool>("rotate180");

  write_lheout = false;
  std::string lhe_ouputfile = iConfig.getUntrackedParameter<std::string>("lhe_outputfilename", "");
  if (!lhe_ouputfile.empty()) {
    write_lheout = true;
    file.open(lhe_ouputfile, std::fstream::out | std::fstream::trunc);
  }

  edm::Service<edm::RandomNumberGenerator> rng;
  if (!rng.isAvailable()) {
    throw cms::Exception("Configuration") << "The PPHXGeneratorLHE requires the RandomNumberGeneratorService\n"
      "which is not present in the configuration file. \n"
      "You must add the service\n"
      "in the configuration file or remove the modules that require it.";
  }
}

PPHXGeneratorLHE::~PPHXGeneratorLHE() {}

//
// member functions
//

// ------------ method called to produce the data  ------------
void PPHXGeneratorLHE::produce(edm::Event &iEvent, const edm::EventSetup &iSetup) {
 
if (verbosity)
    printf("\n>> PPXHGenerator::produce > event %llu\n", e.id().event());

  // get conditions
  edm::Service<edm::RandomNumberGenerator> rng;
  CLHEP::HepRandomEngine* engine = &rng->getEngine(e.streamID());

  double m_H = -1., m_S= -1., m_X = -1.;

  // four-momenta of the outgoing particles in the LAB frame
  CLHEP::HepLorentzVector momentum_H;
  CLHEP::HepLorentzVector momentum_X;

  CLHEP::HepLorentzVector momentum_p1;
  CLHEP::HepLorentzVector momentum_p2;

  // try to generate event fullfilling all criteria
  bool generationOK = false;
  for (unsigned int n_attempt = 0; n_attempt < 10000; ++n_attempt)
  {

    m_H = CLHEP::RandBreitWigner::shoot(engine, m_H_mean, m_H_gamma);
    m_S = CLHEP::RandBreitWigner::shoot(engine, m_S_mean, m_S_gamma);
    m_X = CLHEP::RandBreitWigner::shoot(engine, m_X_mean, m_X_gamma);

    if (m_H < 0. || m_S < m_H + m_X)
      continue;

    // generate p_z of the 2-proton system in the LAB frame
    const double p_z_LAB_2p = CLHEP::RandFlat::shoot(engine, p_z_LAB_2p_min, p_z_LAB_2p_max);

    // generate spherical angles in the CMS frame of the X-Z system
    const double cos_theta_c = 2. * CLHEP::RandFlat::shoot(engine) - 1.;
    const double sin_theta_c = sqrt(1. - cos_theta_c * cos_theta_c);
    const double phi_c = CLHEP::RandFlat::shoot(engine) * 2. * M_PI;

    // determine xi's of the protons
    // proton 1: positive z momentum component
    const double xi2 = (p_z_LAB_2p + sqrt(p_z_LAB_2p*p_z_LAB_2p + m_S*m_S)) / (2. * p_beam);
    const double xi1 = m_S * m_S / (4. * p_beam * p_beam * xi2);

    if (verbosity)
    {
      printf("  m_H = %.1f\n", m_H);
      printf("  m_S = %.1f\n", m_S);
      printf("  p_z_LAB_2p = %.1f\n", p_z_LAB_2p);
      printf("  xi1 = %.3f, xi2 = %.3f\n", xi1, xi2);
      printf("  p_beam * (xi2 - xi1) = %.1f\n", p_beam * (xi2 - xi1));
    }

    // determine momenta of the X and S particles in the CMS frame of the X-S system
    const double p_c_sq = pow(m_S*m_S - m_X*m_X - m_H*m_H, 2.) / (4. * m_S * m_S) - m_X*m_X * m_H*m_H / (m_S*m_S);
    const double p_c = sqrt(p_c_sq);

    if (verbosity)
      printf("  p_c = %.3f\n", p_c);

    CLHEP::HepLorentzVector momentum_X_CMS(
	+ p_c * sin_theta_c * cos(phi_c),
	+ p_c * sin_theta_c * sin(phi_c),
	+ p_c * cos_theta_c,
	sqrt(p_c*p_c + m_X*m_X)
	);

    CLHEP::HepLorentzVector momentum_H_CMS(
	- p_c * sin_theta_c * cos(phi_c),
	- p_c * sin_theta_c * sin(phi_c),
	- p_c * cos_theta_c,
	sqrt(p_c*p_c + m_H*m_H)
	);

    // determine boost from X-H CMS frame to the LAB frame
    const double beta = (xi1 - xi2) / (xi1 + xi2);
    const CLHEP::Hep3Vector betaVector(0., 0., beta);

    if (verbosity)
      printf("  beta = %.3f\n", beta);

    // determine four-momenta of the outgoing particles in the LAB frame
    momentum_H = CLHEP::boostOf(momentum_H_CMS, betaVector);
    momentum_X = CLHEP::boostOf(momentum_X_CMS, betaVector);

    momentum_p1 = CLHEP::HepLorentzVector(0., 0., +p_beam * (1. - xi1), p_beam * (1. - xi1));
    momentum_p2 = CLHEP::HepLorentzVector(0., 0., -p_beam * (1. - xi2), p_beam * (1. - xi2));

    if (verbosity)
    {
      printf("  p_X_z = %.1f\n", momentum_X.z());
      printf("  p_H_z = %.1f\n", momentum_H.z());

      const CLHEP::HepLorentzVector m_tot = momentum_p1 + momentum_p2 + momentum_X + momentum_H;
      printf("  four-momentum of p + p + X + H: (%.1f, %.1f, %.1f | %.1f)\n", m_tot.x(), m_tot.y(), m_tot.z(), m_tot.t());
    }

    if (momentum_H.perp() > p_T_H_min)
    {
      generationOK = true;
      break;
    }
  }

  if (!generationOK)
    throw cms::Exception("PPXHGenerator") << "Failed to generate event.";

  // fill in the LHE record
  unsigned int barcode = 0;

  // status codes
  //const int statusInitial = 3;
  const int statusFinal = 1;
  const int statusDecayed = 2;

  int status_X = (decayX) ? statusDecayed : statusFinal;
  int status_H = (decayHToBottoms) ? statusDecayed : statusFinal;


  HepMC::GenParticle* particle_H = new HepMC::GenParticle(momentum_H, particleId_H, status_H);
  particle_H->suggest_barcode(++barcode);
  vtx->add_particle_out(particle_H);

  HepMC::GenParticle* particle_X = new HepMC::GenParticle(momentum_X, particleId_X, status_X);
  particle_X->suggest_barcode(++barcode);
  vtx->add_particle_out(particle_X);

  HepMC::GenParticle* particle_p1 = new HepMC::GenParticle(momentum_p1, particleId_p, statusFinal);
  particle_p1->suggest_barcode(++barcode);
  vtx->add_particle_out(particle_p1);

  HepMC::GenParticle* particle_p2 = new HepMC::GenParticle(momentum_p2, particleId_p, statusFinal);
  particle_p2->suggest_barcode(++barcode);
  vtx->add_particle_out(particle_p2);




  // decay X if desired
  if (decayX)
  {
    // generate decay angles in X's rest frame;
    const double cos_theta_d = 2. * CLHEP::RandFlat::shoot(engine) - 1.;
    const double sin_theta_d = sqrt(1. - cos_theta_d * cos_theta_d);
    const double phi_d = CLHEP::RandFlat::shoot(engine) * 2. * M_PI;

    // product momentum and energy in X's rest frame
    const double M2 = m_X*m_X - m_f*m_f - m_f*m_f;
    const double p_f = sqrt(M2*M2 - 4. * m_f*m_f * m_f*m_f) / 2. / m_X;
    const double E_f1 = sqrt(p_f*p_f + m_f*m_f);
    const double E_f2 = sqrt(p_f*p_f + m_f*m_f);

    // product four-momenta in X's rest frame
    CLHEP::HepLorentzVector momentum_f1(
	p_f * sin_theta_d * cos(phi_d),
	p_f * sin_theta_d * sin(phi_d),
	p_f * cos_theta_d,
	E_f1
	);

    CLHEP::HepLorentzVector momentum_f2(
	-p_f * sin_theta_d * cos(phi_d),
	-p_f * sin_theta_d * sin(phi_d),
	-p_f * cos_theta_d,
	E_f2
	);

    // apply boost
    double beta = momentum_X.rho() / momentum_X.t();
    CLHEP::Hep3Vector betaVector(momentum_X.x(), momentum_X.y(), momentum_X.z());
    betaVector *= beta / betaVector.mag();
    momentum_f1 = CLHEP::boostOf(momentum_f1, betaVector);
    momentum_f2 = CLHEP::boostOf(momentum_f2, betaVector);

    if (verbosity)
    {
      const CLHEP::HepLorentzVector m_tot = momentum_p1 + momentum_p2 + momentum_H + momentum_f1 + momentum_f2;
      printf("  four-momentum of p + p + H + f1 + f2: (%.5f, %.5f, %.5f | %.5f)\n", m_tot.x(), m_tot.y(), m_tot.z(), m_tot.t());
    }

    // add particles to vertex
    HepMC::GenParticle* particle_f1 = new HepMC::GenParticle(momentum_f1, particleId_f1, statusFinal);
    particle_f1->suggest_barcode(++barcode);
    vtx->add_particle_out(particle_f1);

    HepMC::GenParticle* particle_f2 = new HepMC::GenParticle(momentum_f2, particleId_f2, statusFinal);
    particle_f2->suggest_barcode(++barcode);
    vtx->add_particle_out(particle_f2);
  }

  // decay H if desired
  if (decayHToBottoms)
  {
    double m_l = 0.;
    signed int particleId_l_mi=0, particleId_l_pl=0;

    if (decayHToBottoms) m_l = m_b, particleId_l_mi = particleId_b_mi, particleId_l_pl = particleId_b_pl;

    // generate decay angles in H's rest frame;
    const double cos_theta_d = 2. * CLHEP::RandFlat::shoot(engine) - 1.;
    const double sin_theta_d = sqrt(1. - cos_theta_d * cos_theta_d);
    const double phi_d = CLHEP::RandFlat::shoot(engine) * 2. * M_PI;

    // lepton momentum and energy in H's rest frame
    const double E_l = m_H / 2.;
    const double p_l = sqrt(E_l*E_l - m_l*m_l);

    // lepton four-momenta in H's rest frame
    CLHEP::HepLorentzVector momentum_l_mi(
	p_l * sin_theta_d * cos(phi_d),
	p_l * sin_theta_d * sin(phi_d),
	p_l * cos_theta_d,
	E_l
	);

    CLHEP::HepLorentzVector momentum_l_pl(
	-p_l * sin_theta_d * cos(phi_d),
	-p_l * sin_theta_d * sin(phi_d),
	-p_l * cos_theta_d,
	E_l
	);

    // apply boost
    double beta = momentum_H.rho() / momentum_H.t();
    CLHEP::Hep3Vector betaVector(momentum_H.x(), momentum_H.y(), momentum_H.z());
    betaVector *= beta / betaVector.mag();
    momentum_l_mi = CLHEP::boostOf(momentum_l_mi, betaVector);
    momentum_l_pl = CLHEP::boostOf(momentum_l_pl, betaVector);

    if (verbosity)
    {
      const CLHEP::HepLorentzVector m_tot = momentum_p1 + momentum_p2 + momentum_X + momentum_l_mi + momentum_l_pl;
      printf("  four-momentum of p + p + X + q + qbar: (%.1f, %.1f, %.1f | %.1f)\n", m_tot.x(), m_tot.y(), m_tot.z(), m_tot.t());
    }

    // add particles to vertex
    HepMC::GenParticle* particle_l_mi = new HepMC::GenParticle(momentum_l_mi, particleId_l_mi, statusDecayed); //statusFinal before (fixed by Diego)
    particle_l_mi->suggest_barcode(++barcode);
    vtx->add_particle_out(particle_l_mi);

    HepMC::GenParticle* particle_l_pl = new HepMC::GenParticle(momentum_l_pl, particleId_l_pl, statusDecayed); //statusFinal before (fixed by Diego)
    particle_l_pl->suggest_barcode(++barcode);
    vtx->add_particle_out(particle_l_pl);
  }

  // save output
  //std::unique_ptr<HepMCProduct> output(new HepMCProduct()) ;
  //output->addHepMCData(fEvt);


  double originalXWGTUP_ = 1.;
  std::unique_ptr<LHEEventProduct> product(new LHEEventProduct(hepeup, originalXWGTUP_));
  iEvent.put(std::move(output), "unsmeared");

/*

 using namespace edm;

  edm::Service<edm::RandomNumberGenerator> rng;
  CLHEP::HepRandomEngine *engine = &rng->getEngine(iEvent.streamID());

  TLorentzVector b1, b2;
  bool mu_plus_found = false;
  bool mu_minus_found = false;
  lhef::HEPEUP hepeup;
  hepeup.IDPRUP = 0;
  hepeup.XWGTUP = 1;
  hepeup.SCALUP = -1;
  hepeup.AQEDUP = -1;
  hepeup.AQCDUP = -1;

  // Assuming Pt-Order
     for (edm::View<pat::Muon>::const_iterator muon = coll_muons.begin(); muon != coll_muons.end(); ++muon) {
     if (muon->charge() == 1 && !mu_plus_found) {
     assign_4vector(b1, &(*muon), studyFSRmode_);
     mu_plus_found = true;
     } else if (muon->charge() == -1 && !mu_minus_found) {
     assign_4vector(b2, &(*muon), studyFSRmode_);
     mu_minus_found = true;
     } else if (mu_minus_found && mu_plus_found)
     break;
     }

  // b2 -> 
  //Lepton.SetPxPyPzE(
  //        beforeFSRMuon->p4().px(), beforeFSRMuon->p4().py(), beforeFSRMuon->p4().pz(), beforeFSRMuon->p4().e());


  rotate180(b1, b2);                 // if no rotate180, function does nothing
  transform_mumu_to_tautau(b1, b2);  // if MuonEmbedding, function does nothing.
  fill_lhe_jets(b1, b2, hepeup, engine);

  double originalXWGTUP_ = 1.;
  std::unique_ptr<LHEEventProduct> product(new LHEEventProduct(hepeup, originalXWGTUP_));

  if (write_lheout)
    std::copy(product->begin(), product->end(), std::ostream_iterator<std::string>(file));

  iEvent.put(std::move(product));

*/


}

// ------------ method called once each job just before starting event loop  ------------
void PPHXGeneratorLHE::beginJob() {}

// ------------ method called once each job just after ending the event loop  ------------
void PPHXGeneratorLHE::endJob() {}

// ------------ method called when starting to processes a run  ------------

void PPHXGeneratorLHE::beginRunProduce(edm::Run &run, edm::EventSetup const &) {
  // fill HEPRUP common block and store in edm::Run
  lhef::HEPRUP heprup;

  // set number of processes: 1 for H to bb
  heprup.resize(1);

  //Process independent information

  //beam particles ID (two protons)
  heprup.IDBMUP.first = 2212;
  heprup.IDBMUP.second = 2212;

  //beam particles energies (both 6.5 GeV)
  heprup.EBMUP.first = 6500.;
  heprup.EBMUP.second = 6500.;

  //take default pdf group for both beamparticles
  heprup.PDFGUP.first = -1;
  heprup.PDFGUP.second = -1;

  //take certan pdf set ID (same as in officially produced DYJets LHE files)
  heprup.PDFSUP.first = -1;
  heprup.PDFSUP.second = -1;

  //master switch for event weight iterpretation (same as in officially produced DYJets LHE files)
  heprup.IDWTUP = 3;

  //Information for first process (H to b bbar), for now only placeholder:
  heprup.XSECUP[0] = 1.;
  heprup.XERRUP[0] = 0;
  heprup.XMAXUP[0] = 1;
  heprup.LPRUP[0] = 1;

  std::unique_ptr<LHERunInfoProduct> runInfo(new LHERunInfoProduct(heprup));
  runInfo->addHeader(give_slha());

  if (write_lheout)
    std::copy(runInfo->begin(), runInfo->end(), std::ostream_iterator<std::string>(file));
  run.put(std::move(runInfo));
}

void PPHXGeneratorLHE::endRunProduce(edm::Run &run, edm::EventSetup const &es) {
  if (write_lheout) {
    file << LHERunInfoProduct::endOfFile();
    file.close();
  }
}

void PPHXGeneratorLHE::fill_lhe_jets(TLorentzVector &b1,
    TLorentzVector &b2,
    lhef::HEPEUP &outlhe,
    CLHEP::HepRandomEngine *engine) {
  TLorentzVector H = b1 + b2;
  int quarkPDGID = 5;

  // double tau_ctau = 0.00871100; //cm
  double tau_ctau0 = 8.71100e-02;  // mm (for Pythia)
  double tau_ctau_p =
    tau_ctau0 * CLHEP::RandExponential::shoot(engine);  // return -std::log(HepRandom::getTheEngine()->flat());
  // replaces tau = process[iNow].tau0() * rndmPtr->exp(); from pythia8212/src/ProcessContainer.cc which is not initialized for ProcessLevel:all = off mode (no beam particle mode)
  double tau_ctau_n = tau_ctau0 * CLHEP::RandExponential::shoot(engine);
  //std::cout<<"tau_ctau P: "<<tau_ctau_p<<" tau_ctau N:  "<<tau_ctau_n<<std::endl;

  fill_lhe_with_particle(outlhe, Z, 23, 9.0, 0);
  fill_lhe_with_particle(outlhe, b1, -quarkPDGID, 1.0, tau_ctau_p);
  fill_lhe_with_particle(outlhe, b2, quarkPDGID, -1.0, tau_ctau_n);

  return;
}

void PPHXGeneratorLHE::fill_lhe_with_particle(
    lhef::HEPEUP &outlhe, TLorentzVector &particle, int pdgid, double spin, double ctau) {

  // Pay attention to different index conventions:
  // 'particleindex' follows usual C++ index conventions starting at 0 for a list.
  // 'motherindex' follows the LHE index conventions: 0 is for 'not defined', so the listing starts at 1.
  // That means: LHE index 1 == C++ index 0.

  int particleindex = outlhe.NUP;
  outlhe.resize(outlhe.NUP + 1);

  outlhe.PUP[particleindex][0] = particle.Px();
  outlhe.PUP[particleindex][1] = particle.Py();
  outlhe.PUP[particleindex][2] = particle.Pz();
  outlhe.PUP[particleindex][3] = particle.E();
  outlhe.PUP[particleindex][4] = particle.M();
  outlhe.IDUP[particleindex] = pdgid;
  outlhe.SPINUP[particleindex] = spin;
  outlhe.VTIMUP[particleindex] = ctau;

  outlhe.ICOLUP[particleindex].first = 0;
  outlhe.ICOLUP[particleindex].second = 0;

  if (std::abs(pdgid) == 25) {
    outlhe.MOTHUP[particleindex].first = 0;  // No Mother
    outlhe.MOTHUP[particleindex].second = 0;
    outlhe.ISTUP[particleindex] = 2;  // status
  }

  outlhe.MOTHUP[particleindex].first = 1;   // Mother is the H (first partile)
  outlhe.MOTHUP[particleindex].second = 1;  // Mother is the H (first partile)

  outlhe.ISTUP[particleindex] = 1;  //status

  return;
}

void PPHXGeneratorLHE::transform_mumu_to_tautau(TLorentzVector &b1, TLorentzVector &b2) {


  TLorentzVector H = b1 + b2;

  TVector3 boost_from_H_to_LAB = H.BoostVector();
  TVector3 boost_from_LAB_to_H = -H.BoostVector();

  // Boosting the two leptons to Z restframe, then both are back to back. This means, same 3-momentum squared
  b1.Boost(boost_from_LAB_to_H);
  b2.Boost(boost_from_LAB_to_H);

  // Energy of tau = 0.5*Z-mass
  double q_mass_squared = 4.18 * 4.18;
  //double q_energy_squared = 0.25 * H.M2();
  double q_3momentum_squared = q_energy_squared - q_mass_squared;
  if (q_3momentum_squared < 0) {
    edm::LogWarning("PPHXEmbedding") << "3-Momentum squared is negative";
    return;
  }

  //Computing scale, applying it on the 3-momenta and building new 4 momenta of the taus
  double scale = std::sqrt(q_3momentum_squared / b1.Vect().Mag2());
  b1.SetPxPyPzE(scale * b1.Px(),
      scale * b1.Py(),
      scale * b1.Pz(),
      std::sqrt(lep_energy_squared));
  b2.SetPxPyPzE(scale * b2.Px(),
      scale * b2.Py(),
      scale * b2.Pz(),
      std::sqrt(lep_energy_squared));

  //Boosting the new taus back to LAB frame
  b1.Boost(boost_from_Z_to_LAB);
  b2.Boost(boost_from_Z_to_LAB);

  return;
}




void PPHXGeneratorLHE::rotate180(TLorentzVector &b1, TLorentzVector &b2) {
  if (!rotate180_)
    return;
  edm::LogInfo("PPHXEmbedding") << "Applying 180<C2><B0> rotation";
  // By construction, the 3-momenta of b, bbar and H are in one plane.
  // That means, one vector for perpendicular projection can be used for both leptons.
  TLorentzVector H = b1 + b2;

  edm::LogInfo("PPHXEmbedding") << "b before. Pt: " << b1.Pt() << " Eta: " << b1.Eta()
    << " Phi: " << b1.Phi() << " Mass: " << b1.M();

  TVector3 H3 = H.Vect();
  TVector3 b1_3 = b1.Vect();
  TVector3 b2_3 = b2.Vect();

  TVector3 p3_perp = b1_3 - b1_3.Dot(Z3) / H3.Dot(H3) * H3;
  p3_perp = p3_perp.Unit();

  b1_3 -= 2 * b1_3.Dot(p3_perp) * p3_perp;
  b2_3 -= 2 * b2_3.Dot(p3_perp) * p3_perp;

  b1.SetVect(b1_3);
  b2.SetVect(b2_3);

  edm::LogInfo("PPHXEmbedding") << "b after. Pt: " << b1_3.Pt() << " Eta: " << b1_3.Eta()
    << " Phi: " << b1_3.Phi() << " Mass: " << b1_3.M();

  return;
}

LHERunInfoProduct::Header PPHXGeneratorLHE::give_slha() {
  LHERunInfoProduct::Header slhah("slha");

  slhah.addLine("######################################################################\n");
  slhah.addLine("## PARAM_CARD AUTOMATICALY GENERATED BY MG5 FOLLOWING UFO MODEL   ####\n");
  slhah.addLine("######################################################################\n");
  slhah.addLine("##                                                                  ##\n");
  slhah.addLine("##  Width set on Auto will be computed following the information    ##\n");
  slhah.addLine("##        present in the decay.py files of the model.               ##\n");
  slhah.addLine("##        See  arXiv:1402.1178 for more details.                    ##\n");
  slhah.addLine("##                                                                  ##\n");
  slhah.addLine("######################################################################\n");
  slhah.addLine("\n");
  slhah.addLine("###################################\n");
  slhah.addLine("## INFORMATION FOR MASS\n");
  slhah.addLine("###################################\n");
  slhah.addLine("Block mass \n");
  slhah.addLine("    6 1.730000e+02 # MT \n");
  slhah.addLine("   15 1.777000e+00 # MTA \n");
  slhah.addLine("   23 9.118800e+01 # MZ \n");
  slhah.addLine("   25 1.250000e+02 # MH \n");
  slhah.addLine("## Dependent parameters, given by model restrictions.\n");
  slhah.addLine("## Those values should be edited following the \n");
  slhah.addLine("## analytical expression. MG5 ignores those values \n");
  slhah.addLine("## but they are important for interfacing the output of MG5\n");
  slhah.addLine("## to external program such as Pythia.\n");
  slhah.addLine("  1 0.000000 # d : 0.0 \n");
  slhah.addLine("  2 0.000000 # u : 0.0 \n");
  slhah.addLine("  3 0.000000 # s : 0.0 \n");
  slhah.addLine("  4 0.000000 # c : 0.0 \n");
  slhah.addLine("  5 0.000000 # b : 0.0 \n");
  slhah.addLine("  11 0.000000 # e- : 0.0 \n");
  slhah.addLine("  12 0.000000 # ve : 0.0 \n");
  slhah.addLine("  13 0.000000 # mu- : 0.0 \n");
  slhah.addLine("  14 0.000000 # vm : 0.0 \n");
  slhah.addLine("  16 0.000000 # vt : 0.0 \n");
  slhah.addLine("  21 0.000000 # g : 0.0 \n");
  slhah.addLine("  22 0.000000 # a : 0.0 \n");
  slhah.addLine(
      "  24 80.419002 # w+ : cmath.sqrt(MZ__exp__2/2. + cmath.sqrt(MZ__exp__4/4. - "
      "(aEW*cmath.pi*MZ__exp__2)/(Gf*sqrt__2))) \n");
  slhah.addLine("\n");
  slhah.addLine("###################################\n");
  slhah.addLine("## INFORMATION FOR SMINPUTS\n");
  slhah.addLine("###################################\n");
  slhah.addLine("Block sminputs \n");
  slhah.addLine("    1 1.325070e+02 # aEWM1 \n");
  slhah.addLine("    2 1.166390e-05 # Gf \n");
  slhah.addLine("    3 1.180000e-01 # aS \n");
  slhah.addLine("\n");
  slhah.addLine("###################################\n");
  slhah.addLine("## INFORMATION FOR WOLFENSTEIN\n");
  slhah.addLine("###################################\n");
  slhah.addLine("Block wolfenstein \n");
  slhah.addLine("    1 2.253000e-01 # lamWS \n");
  slhah.addLine("    2 8.080000e-01 # AWS \n");
  slhah.addLine("    3 1.320000e-01 # rhoWS \n");
  slhah.addLine("    4 3.410000e-01 # etaWS \n");
  slhah.addLine("\n");
  slhah.addLine("###################################\n");
  slhah.addLine("## INFORMATION FOR YUKAWA\n");
  slhah.addLine("###################################\n");
  slhah.addLine("Block yukawa \n");
  slhah.addLine("    6 1.730000e+02 # ymt \n");
  slhah.addLine("   15 1.777000e+00 # ymtau \n");
  slhah.addLine("\n");
  slhah.addLine("###################################\n");
  slhah.addLine("## INFORMATION FOR DECAY\n");
  slhah.addLine("###################################\n");
  slhah.addLine("DECAY   6 1.491500e+00 # WT \n");
  slhah.addLine("DECAY  15 2.270000e-12 # WTau \n");
  slhah.addLine("DECAY  23 2.441404e+00 # WZ \n");
  slhah.addLine("DECAY  24 2.047600e+00 # WW \n");
  slhah.addLine("DECAY  25 6.382339e-03 # WH \n");
  slhah.addLine("## Dependent parameters, given by model restrictions.\n");
  slhah.addLine("## Those values should be edited following the \n");
  slhah.addLine("## analytical expression. MG5 ignores those values \n");
  slhah.addLine("## but they are important for interfacing the output of MG5\n");
  slhah.addLine("## to external program such as Pythia.\n");
  slhah.addLine("DECAY  1 0.000000 # d : 0.0 \n");
  slhah.addLine("DECAY  2 0.000000 # u : 0.0 \n");
  slhah.addLine("DECAY  3 0.000000 # s : 0.0 \n");
  slhah.addLine("DECAY  4 0.000000 # c : 0.0 \n");
  slhah.addLine("DECAY  5 0.000000 # b : 0.0 \n");
  slhah.addLine("DECAY  11 0.000000 # e- : 0.0 \n");
  slhah.addLine("DECAY  12 0.000000 # ve : 0.0 \n");
  slhah.addLine("DECAY  13 0.000000 # mu- : 0.0 \n");
  slhah.addLine("DECAY  14 0.000000 # vm : 0.0 \n");
  slhah.addLine("DECAY  16 0.000000 # vt : 0.0 \n");
  slhah.addLine("DECAY  21 0.000000 # g : 0.0 \n");
  slhah.addLine("DECAY  22 0.000000 # a : 0.0\n");

  return slhah;
}

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void PPHXGeneratorLHE::fillDescriptions(edm::ConfigurationDescriptions &descriptions) {
  //The following says we do not know what parameters are allowed so do no validation
  // Please change this to state exactly what you do use, even if it is no parameters
  edm::ParameterSetDescription desc;
  desc.setUnknown();
  descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(PPHXGeneratorLHE);


